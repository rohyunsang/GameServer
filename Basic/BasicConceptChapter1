program : code + data
Run => program : code + data + heap + stack 

Program is on disk, Process is on RAM memory

multiple processes running => Multi-Processing 

void main()
{
    t2 = CreateThread(Thread2Proc);
}

void Thread2Proc()
{
    t3 = CreateThread(Thread3Proc);
}

void Thread3Proc()
{
    t4 = CreateThread(Thread4Proc);
}

A program consists of many subroutines or functions

When a function finishes executing, it returns to the point 
where it executed the caller function that called itself.
this information is stored is called the call stack.

1. 생성
2. 실행 중 (Runnable)
3. 대기 중 (Blocked)
4. 소멸 (Dead)

if Runnable another thread, Dead main thread => Zombie thread

modern cpp create thread 
std::thread t1(ThreadProc, 123);

Context Switch 

if two thread use one variable => data race => Possibility incorrect calculation result

동기화(synchronize) : 대표적인 것이 임계 영역과 뮤텍스, lock 기법.
임계 영역(critical section) 
mutex : dont use variable until current thread finish
mutex(mutual exclusion)

lock_guard : auto unlcok class





